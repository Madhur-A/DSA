/*
Copyright (C) 2024  A. Madhur

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/


#ifndef DEFINES_HPP
#define DEFINES_HPP 1

/*** caution -- remove this header from production -- ***/
/* header for fast debugging utility, useless trivia and many other pointless things */

#include <cstdio>
#include <string>
#include <vector>
#include <stdexcept>
#include <ctime>
#include <cmath>
#include <fstream>
#include <ostream>
#include <locale>
#include <utility>
#include <functional>
#include <iostream>
#include <algorithm>
#include <cinttypes>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>

// #include <thread>
// #include <mutex>
// #include <future>
// #include <condition_variable>
// #include <atomic>

//freq used types
#define i_int std::size_t
#define g_int int64_t

//mathematical constants
#define m_pi 3.141592653589793238462643383279502884197169399375105820974944592307816406286
#define get_random(arg) ((decltype(arg))(rand()) % (arg)) //random number generation

//C++17, C++20 et el
//#define constant constexpr thread_local // clashes with expansion of macro ‘constant’ in numpy/ndarraytypes.h:1398:11
#define unuse_suppressor [[maybe_unused]]
#define instantaneous inline static constexpr
#define rapid_claused inline constexpr
#define forcing_inline __attribute__((always_inline))
#define cstring const char*
#define xstring constexpr const char*

//casts [these macros conflict with boost]
// #define as_double(arg) static_cast<double>(arg)
// #define as_int(arg)    static_cast<int>(arg)
// #define as_size_t(arg) static_cast<std::size_t>(arg)
// #define as_long(arg)   static_cast<long>(arg)

// loops
#define __for_loop_statement(__ln) for(std::size_t i=0; i<__ln; ++i)
#define __for_k(__ln) for(std::size_t k=0; k<__ln; ++k)
#define __for_i(__ln) for(std::size_t i=0; i<__ln; ++i)
#define __for_j(__ln) for(std::size_t j=0; j<__ln; ++j)

#define execute_for(arg, N) __for_##arg(N)

//input values
#define guard(info) if(argc == 1) { printf("\x1b[95m%s\x1b[0m\n", info); exit(1); }
#define arg_v(k) (int)std::strtod(argv[k], nullptr)
#define entry_guard(__ln, __info) if(argc < __ln) { printf("\x1b[95m%s\x1b[0m\n", __info); exit(1); }

// error handling and exceptions
#define __invalid_arg_error(arg) std::__throw_invalid_argument(arg)
#define error_throw(invalid, arg) __##invalid_arg_error(arg)


// TMP
// TMP[OLD]
#define expression_type template <typename> typename
// TMP[OLD/]
#define siexpressn_type template <typename> typename
#define duexpressn_type template <typename, typename> typename
#define trexpressn_type template <typename, typename, typename> typename
#define vrexpressn_type template <typename... > typename
#define definition_type typename
#define configuring     template

//[BEGIN]debugging macros 
#define echo_line std::puts("---------------------------------------------------------------------------------------")
#define print_new_line std::putc('\n', stdout)
#define endL print_new_line
// #define print(arg) puts(std::string(arg).c_str())
// #define print_msg_ld(arg1, arg2) std::fprintf(stdout, "%s ", arg1.c_str(), "%ld\n", arg2)
//[END]  debugging macros [not-to-be-included in production code]

namespace __the_aamrapali_victory {
    // for printing/debugging
    // works for:
    // (1) std::vector<typenam> (2) std::vector<std::vector<typename>> (3) std::unordered_map/_set/map/set/
    template <typename __tp_ostream>
    struct __print {
    public:
    	using ostream_type  = __tp_ostream;
    private:
        template<typename __tp, typename = void>
        struct _i_print {
        public:
            inline constexpr static int _iprint(bool const &new_line, ostream_type &_os, __tp const &tp) {
                new_line ? _os << tp << '\0' : _os << tp << ' ';
                return 1;
            }
        };

        template<typename __tp>
        struct _i_print<__tp, std::void_t<typename __tp::iterator>> {
	public:
            inline constexpr static int _iprint(bool const &new_line, ostream_type &_os, __tp const &tp) {
		using iterator_value_type = typename __tp::const_iterator::value_type;
		
                typename __tp::const_iterator _begin  =   tp.begin();
                typename __tp::const_iterator   _end  =   tp.end();
                typename __tp::const_iterator _second = --tp.end();
		
                _os << '[';
		while(_begin != _end) {
		    _begin != _second ?
			_i_print<iterator_value_type>::_iprint(false, _os, *_begin) :
			_i_print<iterator_value_type>::_iprint(true, _os, *_begin);
		    ++_begin;
		}
                new_line ? _os << ']' : _os << ']' << ',' << ' ';
                return 1;
            }
        };       
    public:
    	template <typename __tpl>
    	inline constexpr static int writeln(ostream_type &_os, __tpl const &h) {            
    	    return _i_print<__tpl>::_iprint(true, _os, h);
    	}
	
    	template <typename __tpl, typename ... __tp_args>
    	inline constexpr static int writeln(ostream_type &_os, __tpl const &h, __tp_args const& ...args) { 
    	    return _i_print<__tpl>::_iprint(false, _os, h) + writeln(_os, args...);
    	}
    };

    template <typename ... __tp_args>
    inline constexpr int println(__tp_args const& ... args) {
	using printer = __print<std::basic_ostream<char>>;
        return printer::writeln(std::cout, args...) + printer::writeln(std::cout, '\n');
    }
    
    inline constexpr int println() { return println('\0'); }
    
    template <typename __graph> //overload for graph-types; "key: {values, ...}"
    inline constexpr int printgf(__graph const& __g, bool const &__braces=false) {
	using value_type = typename __graph::value_type;
	for(value_type const &__node: __g) {
	    (__braces) ?
	    	println(__node.first, ": {", __node.second, "}") :
	    	println(__node.first, ": ", __node.second);
	}
	return 1;
    }    
}


namespace {
    template <typename>
    struct __config {
	inline static constexpr void reconfigure_io() noexcept(false) {
	    std::cout.setf(std::ios::boolalpha);
	    std::cout.imbue(std::locale("en_IN.UTF-8"));
	    std::cout.precision(25);
	}
	inline static constexpr int flush_io() noexcept(false) {
	    std::ios::sync_with_stdio(false);
	    std::cin.tie(nullptr);
	    return 0;
	}
    };
    using config = __config<void>;
}


// some common functions in constexpr flavours
// if only I'd the idea that these functions are already in constexpr
// variations from the standard library.
namespace __the_aamrapali_victory {
    template <typename __tp_element>
    struct __sq_root {
	/*
	 * this algorithm is due to Bakshli manuscript. 
	 * [For more information] please refer to (https://www.davidhbailey.com//dhbpapers/india-sqrt.pdf)
	 */
    public:
	using element_type = __tp_element;
    private:
	element_type  _input_number;
	element_type  _output_number;
    public:	
	inline constexpr element_type __initial_approxiamtion() const noexcept(false) {
	    if(this->_input_number == 0.0) { return element_type(); }
	    element_type const epsilon = (1.0/this->_input_number) < 1.0 ? 1.0 : (this->_input_number/100.0);
	    element_type const   delta = epsilon == 1.0 ? this->_input_number/2.0 : 1.0;
	    for(element_type i=0; i<=delta; i=i+epsilon) {
		element_type const previous_number = i;
		if(((i+epsilon) * (i+epsilon)) > _input_number) {
		    return previous_number;
		}
	    }
	    return element_type();
	}
	inline constexpr element_type __value_an(element_type const &xn) const noexcept(false) { return ((this->_input_number) - (xn * xn))/(2.0*xn); }
    public:
	inline constexpr __sq_root(element_type const input_nubmer): _input_number(input_nubmer),
								     _output_number(element_type()) {
	    element_type xn = this->__initial_approxiamtion();
	    for(short i=0; i<10; ++i) {
		element_type an = __value_an(xn);
		element_type bn = xn + an;
		xn = (bn - ((an*an)/(2.0*bn)));
	    }
	    this->_output_number = xn;
	}
	inline constexpr element_type value()      const noexcept(false) { return this->_output_number; }
	inline constexpr element_type operator()() const noexcept(false) { return this->_output_number; }
	inline constexpr operator element_type()   const noexcept(false) { return this->_output_number; }
	// inline constexpr ~__sq_root() noexcept(false) {}
    };

    template <typename __tp_element>
    struct __square_root {
    public:
	using element_type = __tp_element;
    public:
	inline static constexpr element_type value(element_type const &_input_number) {
	    __sq_root<element_type> constexpr sqroot(_input_number);
	    return sqroot();
	}
    };

    // string specific measurments, where string referes to c-style c++-compatible string
    // e.g. `const char*` or `constexpr const char*`
    
    struct __cstring {
        inline static constexpr int has_value(cstring __in_string) noexcept(false) {
            int __measure = 0;
            if(__in_string != 0) {
                while(*__in_string++ != '\0') {
                    ++__measure;
                }
            }
            return __measure;
        }
        inline static constexpr int len(cstring __in_string) noexcept(false) {
	    return has_value(__in_string);
        }
        inline static constexpr int length(cstring __in_string) noexcept(false) {
	    return has_value(__in_string);
        }	
        inline static int newline_count(cstring __file_address) noexcept(false) {
            int __measure = 0;
	    try {
		FILE *f = std::fopen(__file_address, "r");
		int c = 0;
		while((c = std::fgetc(f)) != EOF) {
		    if(c == '\n') { ++__measure; }
		}
		std::fclose(f);
	    } catch(...) {}
            return __measure;
        }
    };

    // palindrome string specific operations
    template <typename __cstring_version>
    struct __manachered {
    public:
        using primal_cstring = __cstring_version;
    private:
        primal_cstring   _in_string;
        int              _len;
        int              _len_max;
        int              _pl_index;
	int              _r_ln;
    public:
        inline constexpr __manachered(primal_cstring input_string) noexcept(false): _in_string(input_string),
										    _len(__cstring::has_value(input_string)),
										    _len_max(0),
										    _pl_index(0), _r_ln(0) {
            int const b_len = (2*_len) + 1; int i=0;
            char  *b_string = new char[b_len+1];
            b_string[0] = '*'; b_string[1] = _in_string[0]; //{'*', _in_string[0]};
            for(i=2; i<b_len; ++i) { b_string[i] = i % 2 == 0 ? '*' : input_string[static_cast<int>(i/2)]; }
            b_string[i] = '\0';
            int *p_radii = new int[b_len]; // this heap usage also slows the execution
            for(int i=0; i<b_len; p_radii[i]=0, ++i);
            int k = 0; int r = 0;
            while(k < b_len) {
                while((k-(r+1) >= 0) && (k+(r+1) < b_len) && (b_string[k-(r+1)] == b_string[k+(r+1)])) {
                    r = r + 1;
                }
                int prv_k = k;
                int prv_r = r;
                p_radii[k] = r;
                k = k + 1;
                r = 0;
                while(k <= (prv_k + prv_r)) {
                    int mirrored_max_center = prv_k - (k - prv_k);
                    int mirrored_max_radius = prv_k + prv_r - k;
                    if(p_radii[mirrored_max_center] < mirrored_max_radius) {
                        p_radii[k] = p_radii[mirrored_max_center];
                        k = k + 1;
                    } else if(p_radii[mirrored_max_center] > mirrored_max_radius) {
                        p_radii[k] = mirrored_max_radius;
                        k = k + 1;
                    } else {
                        r = mirrored_max_radius;
                        break;
                    }
                }
	    }
            for(int i=0; i<b_len; ++i) { if(p_radii[i] > _len_max) { _len_max  = p_radii[i]; _pl_index = i; } }
            delete[] b_string;
            delete[] p_radii;
            int const o_ix = (_pl_index-1)/2;
            this->_r_ln = _len_max % 2 == 0 ? o_ix - ((_len_max/2)-1) : o_ix - (_len_max/2);
            // for(int i=r_ln; i<r_ln+_len_max; _op_buffer.operator+=(_in_string[i]),++i);
        }
        // inline constexpr cpp_string d_show() const noexcept(false) { return _op_buffer; }
	inline constexpr void containerize(char* __canister) const noexcept(false) {
	    int i=0;
	    for(i=_r_ln; i<_r_ln+_len_max; __canister[i-_r_ln] = _in_string[i], ++i);
	    __canister[i-_r_ln] = '\0';
	}
        inline constexpr int mx_length() const noexcept(false) { return _len_max; }
    };    

    struct palindrome {
    public:
	inline static constexpr bool is_palindrome(char const *in_string) { // make this recursif 
	    char *tmp = const_cast<char*>(in_string);
	    char *ump = const_cast<char*>(in_string);
	    while(*ump != '\0') { ump++; }
	    while(*tmp != '\0') {
		ump--;
		if(*tmp == *ump) {
		    ++tmp;
		    continue;
		} else {
		    return false;
		}
	    }
	    return *tmp == '\0';
	}
	
	inline static constexpr unsigned palindrome_measure(char const *in_string) {
	    return is_palindrome(in_string) ? __the_aamrapali_victory::__cstring::has_value(in_string) : 0;
	}
	inline static constexpr void max_palindrome_segment(char const* in_string, char* buffer) {
	    __manachered<char const*> w(in_string);
	    w.containerize(buffer);
	}
	inline static constexpr unsigned max_palindrome_segment(char const* in_string) {
	    __manachered<char const*> w(in_string);
	    return w.mx_length();
	    // unsigned const n = __the_aamrapali_victory::__cstring_measure::has_value(in_string);
	    // char buffer[20000] = {};
	    // unsigned ix = 0;
	    // unsigned max_value = 0;
	    // for(unsigned i=0; i<n; ++i) {
	    // 	for(unsigned j=i; j<n; ++j) {
	    // 	    for(unsigned xi=i; xi<=j; ++xi) { buffer[xi-i] = in_string[xi]; ix = xi-i; }
	    // 	    buffer[++ix] = '\0';
	    // 	    unsigned const p_value = __the_aamrapali_victory::palindrome::palindrome_measure(buffer);
	    // 	    max_value = p_value > max_value ? p_value : max_value;
	    // 	}
	    // }
	    // return max_value;
	}
    };

    // union-find data structure
    template <typename __buffer_type>
    struct __uf {
    public:
	using value_type  = unsigned long;
	using buffer_type = __buffer_type;
    private:
	value_type  length;
	buffer_type parents, ranks;
    public:
	inline __uf(value_type const &n): length(n), parents(n), ranks(n) {
	    for(value_type i=0; i<length; parents[i] = i, ++i);
	}
	inline bool reunion(value_type const &i, value_type const &j) {
	    value_type const parent_i = find(i), parent_j = find(j);
	    if(parent_i != parent_j) {
		value_type const rank_pi = ranks[parent_i], rank_pj = ranks[parent_j];
		if(rank_pi != rank_pj) {
		    parents[parent_i] = (rank_pi < rank_pj) ? parent_j : parents[parent_i];
		    parents[parent_j] = (rank_pi > rank_pj) ? parent_i : parents[parent_j];
		} else {
		    parents[parent_i] = parent_j;
		    ranks[parent_j]++;
		}
		return true;
	    }
	    return false;
	}
	inline value_type find(value_type const &index) { return (parents[index] == index) ? index : find(parents[index]); }
	inline void reset() {	    
	    for(value_type i=0; i<length; parents[i] = i, ranks[i] = 0, ++i);
	}
    };

    using uf = __uf<std::vector<int>>;
}

namespace av = __the_aamrapali_victory;

#endif // DEFINES_HPP
